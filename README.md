![](image/snatcher.png)

---

## 项目背景

本项目的构思起源于学校的选课系统。每逢选课期间，学校的网站就会变得非常卡。这时候选课会变得极其困难，一个网页从请求到响应的时间最长在半个小时左右，这样长时间的等待会使人极其不耐烦。导致很多同学都无法安心的完成选课。这时候会有很多“选课高手”，他们有所谓的“选课技巧”可以快速完成选课。

渐渐的，“选课”这个词演变成为“抢课”。此时抢课也成为了一个“小商机”。据我所知，绝大多数帮选课的也都是手动完成的，这意味着他们需要花费大量的时间在页面等待这方面，同时也意味着“帮忙”的数量会受到浏览器多开窗口个数的限制。随着浏览器多开窗口的增多，出错率也会增加。例如某个窗口对应的同学需要选择课程A，但是由于人类的粗心大意，将课程选择成了课程B……

这时我在想：“为什么不开发出一个脚本，可以帮助我完成选课呢？”——最早起源于作者大一上学期（2022年）。

为此本项目应运而生。

## 项目开发周期

2023年10月24日——2024年3月27日

期间在2023年12月25日进行了小数量测试，目的是为了验证项目的可行性。

## 项目技术栈

+ 后端：FastAPI、MySQL、Redis、Celery。
+ 前端：Vue3、Element-Plus。
+ 部署方案：云服务器（前端） + 本地内网穿透（后端）。

## 系统设计思路

+ ### 系统运行流程

  ![](image/%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

  说明：不管用户的信息是否合法，前端都会直接返回结果，而不会一直处于阻塞状态。

+ ### 核心功能（Snatcher）设计

  ![](image/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84.jpg)

  

  在这里简单描述一下：

  1. 在选课API被调用之前，系统会提前挂起一个Celery的任务队列进程，该进程用于监听选课API提交的任务。
  2. 在API被调用之后，Celery-Worker会监听到有任务被提交，于是将任务从队列中取出。
  3. 当任务被取出之后，假如任务类型是“select_course”，那么首先会检查Redis中是否包含用户对应的会话。如果没有，系统会主动地去保存会话（如果会话设置失败，任务会直接结束）。接着获取选课的时间，最后将选课任务再次发送到Celery任务队列。
  4. 当到达任务设定的时间之后，Celery-Worker会不断的从任务队列中取出并执行任务。
  5. 当任务被执行后，调用相应的课程选择器来进行选课操作，期间任意一个关键步骤失败都会记录失败信息，失败后会重试。当到达最大重试次数后（这里设置的是3次），直接判定选课失败。
  6. 最后整个任务执行完毕。

+ ### 课程选择器设计思路

  课程选择器的本质其实就是一个爬虫程序，只不过就是经过反复抽象，最终成为了一个可扩展性非常强的课程选择器类。

  在“/snatcher/selector/base.py”下，定义了一个名为“BaseCourseSelector”的类，它是所有课程选择器类的父类。在这个类中没有编写任何的爬虫逻辑，只是为这个类初始化了一些属性和方法。

  在这个文件下有一个名为“CourseSelector”的派生类，本质上还是“BaseCourseSelector”这个类。只不过是希望外部类继承“CourseSelector”这个类罢了。

  而“CourseSelector”这个类又派生出了两个子类，他们分别是：

  + SynchronousCourseSelector

    同步课程选择器，该类所处的文件目录为：“/snatcher/selector/sync_selector.py”。该类表示所有发送请求使用的库都是“requests”。所有代码逻辑都是阻塞非异步的。

    在这个类中，实现了基本的选课操作，但它仍然不能够完成一个完整的选课请求。因此往下又派生出了两个子类：

    1. SynchronousPublicChoiceCourseSelector

       同步公选课课程选择器，它弥补了父类中的一些逻辑空缺，实现了完整的选课逻辑。

    2. SynchronousPhysicalEducationCourseSelector

       同步体育课课程选择器，与它的兄弟类作用基本一致。

  + AsynchronousCourseSelector

    异步课程选择器，该类所处的文件目录为：“/snatcher/selector/async_selector.py”。该类表示所有发送请求使用的库都是“aiohttp”。所有代码逻辑都是异步非阻塞的。

    和同步课程选择器一样，同样派生出了两个重要的子类：

    1. AsynchronousPublicChoiceCourseSelector
    2. AsynchronousPhysicalEducationCourseSelector

  __如果你觉得上述文字太多，那么你也可以通过观看以下这张图片清晰地了解课程选择器类的实现：__

  ![](image/%E8%AF%BE%E7%A8%8B%E9%80%89%E6%8B%A9%E5%99%A8.png)

+ ###  解耦式开发思想

  所谓“解耦”，就是低耦合。表示每个模块或者功能之间没有太多的依赖关系，每个模块或者功能单独拿出来也能够正常使用，提高了模块或者功能的可复用性。

  例如本项目中的课程选择器，单独拿出来也是可以使用的；还有snatcher整个包，不需要依赖前端的调用，手动调用也完全可以实现对应的功能，它提供了一个统一的对外接口，以至于让所有的Python程序都能够轻松的调用它。

  其实snatcher可以完全脱离前端和后端使用，只不过为了让这个系统对外部调用者显得更加友好，所以最终决定以Web的形式呈现到用户的眼中，同时也提高了整个系统的安全性。

## 关于项目部署

在部署方面，可能是这个项目最致命的缺点，在这里我详细的分析一下：

首先选课这个操作是必须要在校园网下进行的，也就是说当前网络是一个局域网。只有当前设备的网络环境处于校园网下，才能正常进行选课操作（当然，如果你是老师，有将会专属的VPN来访问校园网）。

所以整个发送请求的过程，都必须在本地进行，不能在云服务器上。因为云服务器的网络不是校园网，它是不能访问本地局域网的。当然，我也有想过让云服务器与本地局域网之间实现数据互通，但最终还是做不到……

因此刚开始我想的是把整个项目都部署在本地，通过内网穿透的形式将服务映射到外网，这种方式是行得通的。但是这样做会有一个弊端，由于内网穿透是通过端口映射的，也就是说只有当前端处于运行的状态下，才会暴露出一个端口，但是前端直接运行的代码是没有经过编译的，每一次网络传输都要传输大量的未经编译的数据，这样做的结果只有一个，那就是传输效率低，传输速度慢。这里是经过了实践的，将一个普通的Vue3应用映射出去，客户端的渲染时间达到了十几秒。

传输速度过慢以及客户端渲染的时间较长，可能是因为未编译过的前端文件过多再加上内网穿透的传输速度较慢，导致了客户端渲染的时间过长。

因此我最终决定将前端打包放在云服务上，将后端的服务通过内网穿透映射出去。在这里前后端都是使用JSON来进行交互的，而JSON本身是个轻量级数据，所以传输速度得到了一个很大的提升。加上前端本身是已经编译好的，所以客户端渲染的速度也非常快。

所以项目最终的部署方案是：将前端打包独自放在云服务器上，而其他所有资源都部署在本地。

这样部署的缺点就是只有当本地服务启动的时候，外部才能使用正常的服务。而本地服务是不能过长时间启动的，因为电脑总要关机嘛。所以我在开头的时候说部署是这个项目最致命的缺点就是这个意思。

