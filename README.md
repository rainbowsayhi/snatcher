![](image/snatcher.png)

---

### 项目背景

本项目的构思起源于学校的选课系统。每逢选课期间，学校的网站就会变得非常卡。这时候选课会变得极其困难，一个网页从请求到响应的时间最长在半个小时左右，这样长时间的等待会使人极其不耐烦。导致很多同学都无法安心的完成选课。这时候会有很多“选课高手”，他们有所谓的“选课技巧”可以快速完成选课。

渐渐的，“选课”这个词演变成为“抢课”。此时抢课也成为了一个“小商机”。据我所知，绝大多数帮选课的也都是手动完成的，这意味着他们需要花费大量的时间在页面等待这方面，同时也意味着“帮忙”的数量会受到浏览器多开窗口个数的限制。随着浏览器多开窗口的增多，出错率也会增加。例如某个窗口对应的同学需要选择课程A，但是由于人类的粗心大意，将课程选择成了课程B……

这时我在想：“为什么不开发出一个脚本，可以帮助我完成选课呢？”——最早起源于作者大一上学期（2022年）。

为此本项目应运而生。

### 项目开发周期

* 2023年10月24日：项目开发启动。
* 2023年12月25日：小数量测试，验证核心功能可行性。
* 2024年3月27日：核心功能基本开发完毕。
* 2024年4月22日：项目首次上线。
* 2024年4月23日 至 2024年6月28日：二次开发阶段。
* 2024年6月29日：项目二次上线并按计划完成所有选课任务。

### 项目技术栈

+ 后端：`FastAPI`、`MySQL`、`Redis`、`Celery`、`RabbitMQ`。
+ 前端：`Vue3`、`Element-Plus`。
+ 部署方案：云服务器（前端） + 本地内网穿透（后端）。

### 项目亮点

1. 利用 **爬虫** 技术向选课接口发送请求，加快选课速度。
2. 利用 **消息队列** 实现 **多任务 + 定时** 爬虫任务。
3. 使用`Redis`**发布订阅** 和`WebSocket`**全双工通信** 实现对选课任务的实时监控。
4. 利用 **缓存** 技术对选课参数进行 **复用**，更进一步地加快了选课速度。

### 系统设计思路

+ #### 系统运行流程

  ![](image/%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

  说明：不管用户的信息是否合法，前端都会直接返回结果，而不会一直处于阻塞状态。

+ #### 核心功能（Snatcher）设计

  ![](image/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84.jpg)

  

  在这里简单描述一下：

  1. 在选课API被调用之前，系统会提前挂起一个`Celery`的任务队列进程，该进程用于监听选课API提交的任务。
  2. 在API被调用之后，`Celery-Worker`会监听到有任务被提交，于是将任务从队列中取出。
  3. 当任务被取出之后，假如任务类型是`select_course`，那么首先会检查`Redis`中是否包含用户对应的会话。如果没有，系统会主动地去保存会话（如果会话设置失败，任务会直接结束）。接着获取选课的时间，最后将选课任务再次发送到`Celery`任务队列。
  4. 当到达任务设定的时间之后，`Celery-Worker`会不断的从任务队列中取出并执行任务。
  5. 当任务被执行后，调用相应的课程选择器来进行选课操作，期间任意一个关键步骤失败都会记录失败信息，失败后会重试。当到达最大重试次数后（这里设置的是3次），直接判定选课失败。
  6. 最后整个任务执行完毕。

+ #### 课程选择器设计思路

  课程选择器的本质其实就是一个爬虫程序，只不过就是经过反复抽象，最终成为了一个可扩展性非常强的课程选择器类。

  在`/snatcher/selector/base.py`下，定义了一个名为`BaseCourseSelector`的类，它是所有课程选择器类的父类。在这个类中没有编写任何的爬虫逻辑，只是为这个类初始化了一些属性。

  在这个文件下有一个名为`CourseSelector`的派生类，它定义了一个课程选择器应该具有的方法。

  而`CourseSelector`这个类又派生出了两个子类，他们分别是：

  + `SynchronousCourseSelector（现已弃用）`

    同步课程选择器，该类所处的文件目录为：`/snatcher/selector/sync_selector.py`。该类表示所有发送请求使用的库都是`requests`。所有代码逻辑都是阻塞非异步的。

    在这个类中，实现了基本的选课操作，但它仍然不能够完成一个完整的选课请求。因此往下又派生出了两个子类：

    1. `SynchronousPublicChoiceCourseSelector（现已弃用）`

       同步公选课课程选择器，它弥补了父类中的一些逻辑空缺，实现了完整的选课逻辑。

    2. `SynchronousPhysicalEducationCourseSelector（现已弃用）`

       同步体育课课程选择器，与它的兄弟类作用基本一致。

  + `AsynchronousCourseSelector`

    异步课程选择器，该类所处的文件目录为：`/snatcher/selector/async_selector.py`。该类表示所有发送请求使用的库都是“aiohttp”。所有代码逻辑都是异步非阻塞的。

    和同步课程选择器一样，同样派生出了两个重要的子类：

    1. `AsynchronousPublicChoiceCourseSelector`
    2. `AsynchronousPhysicalEducationCourseSelector`

  __如果你觉得上述文字太多，那么你也可以通过观看以下这张图片清晰地了解课程选择器类的实现：__

  ![](image/%E8%AF%BE%E7%A8%8B%E9%80%89%E6%8B%A9%E5%99%A8.png)

+ ####  解耦式开发思想

  所谓“解耦”，就是低耦合。表示每个模块或者功能之间没有太多的依赖关系，每个模块或者功能单独拿出来也能够正常使用，提高了模块或者功能的可复用性。

  例如本项目中的课程选择器，单独拿出来也是可以使用的；还有`snatcher`整个包，不需要依赖前端的调用，手动调用也完全可以实现对应的功能，它提供了一个统一的对外接口，以至于让所有的Python程序都能够轻松的调用它。

  其实`snatcher`可以完全脱离前端和后端使用，只不过为了让这个系统对外部调用者显得更加友好，所以最终决定以Web的形式呈现到用户的眼中，同时也提高了整个系统的安全性。

### 项目目录说明

在项目的根目录下，包含以下几个重要的文件或文件夹：

+ `backend`：后端模块，主要负责向外部提供接口。接口包括课程模块和后台管理模块。
+ `frontend`：前端模块，负责为用户提供一个可视化界面，以用于选课。
+ `manager`：后台管理模块，对整个系统的数据和日志有一个上帝视角。
+ `snatcher`：系统核心模块，所有选课逻辑位于该目录下（说明文档要点进去才有）。
+ `logs`：记录每次选课的日志信息。
+ `db.sql`：数据库所需的表结构。
+ `mysqlconf.json`：数据库连接配置文件。
+ `requirements.txt`：系统运行所需的第三方库。

### 关于项目部署

在部署方面，可能是这个项目最致命的缺点，在这里我详细的分析一下：

首先选课这个操作是必须要在校园网下进行的，也就是说当前网络是一个局域网。只有当前设备的网络环境处于校园网下，才能正常进行选课操作（当然，如果你是老师，有将会专属的VPN来访问校园网）。

所以整个发送请求的过程，都必须在本地进行，不能在云服务器上。因为云服务器的网络不是校园网，它是不能访问本地局域网的。当然，我也有想过让云服务器与本地局域网之间实现数据互通，但最终还是做不到……

因此刚开始我想的是把整个项目都部署在本地，通过内网穿透的形式将服务映射到外网，这种方式是行得通的。但是这样做会有一个弊端，由于内网穿透是通过端口映射的，也就是说只有当前端处于运行的状态下，才会暴露出一个端口，但是前端直接运行的代码是没有经过编译的，每一次网络传输都要传输大量的未经编译的数据，这样做的结果只有一个，那就是传输效率低，传输速度慢。这里是经过了实践的，将一个普通的`Vue3`应用映射出去，客户端的渲染时间达到了十几秒。

传输速度过慢以及客户端渲染的时间较长，可能是因为未编译过的前端文件过多再加上内网穿透的传输速度较慢，导致了客户端渲染的时间过长。

因此我最终决定__将前端打包放在云服务上，将后端的服务通过内网穿透映射出去__。在这里前后端都是使用`JSON`来进行交互的，而`JSON`本身是个轻量级数据，所以传输速度得到了一个很大的提升。加上前端本身是已经编译好的，所以客户端渲染的速度也非常快。

所以项目最终的部署方案是：将前端打包独自放在云服务器上，而其他所有资源都部署在本地。

这样部署的缺点就是只有当本地服务启动的时候，外部才能使用正常的服务。而本地服务是不能过长时间启动的，因为电脑总要关机嘛。所以我在开头的时候说部署是这个项目最致命的缺点就是这个意思。



