![](image/snatcher.png)

---

## 项目背景

本项目的构思起源于学校的选课系统。每逢选课期间，学校的网站就会变得非常卡。这时候选课会变得极其困难，一个网页从请求到响应的时间最长在半个小时左右，这样长时间的等待会使人极其不耐烦。导致很多同学都无法安心的完成选课。这时候会有很多“选课高手”，他们有所谓的“选课技巧”可以快速完成选课。

渐渐的，“选课”这个词演变成为“抢课”。此时抢课也成为了一个“小商机”。据我所知，绝大多数帮选课的也都是手动完成的，这意味着他们需要花费大量的时间在页面等待这方面，同时也意味着“帮忙”的数量会受到浏览器多开窗口个数的限制。随着浏览器多开窗口的增多，出错率也会增加。例如某个窗口对应的同学需要选择课程A，但是由于人类的粗心大意，将课程选择成了课程B……

这时我在想：“为什么不开发出一个脚本，可以帮助我完成选课呢？”——最早起源于作者大一上学期（2022年）。

为此本项目应运而生。

## 项目开发时间线

* 2023年10月24日：项目开发启动。
* 2023年12月25日：小数量测试，验证核心功能可行性。
* 2024年3月27日：核心功能基本开发完毕。
* 2024年4月22日：项目首次上线，但情况不太乐观。
* 2024年4月23日至今：核心功能二次开发阶段。

## 项目技术栈

+ 后端：`FastAPI`、`MySQL`、`Redis`、`异步Redis`、`Celery`、`异步Celery`、`RabbitMQ`。
+ 前端：`Vue3`、`Element-Plus`。
+ 部署方案：云服务器（前端） + 本地内网穿透（后端）。

## 系统设计思路

+ ### 系统运行流程

  ![](image/%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

  说明：不管用户的信息是否合法，前端都会直接返回结果，而不会一直处于阻塞状态。

+ ### 核心功能（Snatcher）设计

  ![](image/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84.jpg)

  

  在这里简单描述一下：

  1. 在选课API被调用之前，系统会提前挂起一个`Celery`的任务队列进程，该进程用于监听选课API提交的任务。
  2. 在API被调用之后，`Celery-Worker`会监听到有任务被提交，于是将任务从队列中取出。
  3. 当任务被取出之后，假如任务类型是`select_course`，那么首先会检查`Redis`中是否包含用户对应的会话。如果没有，系统会主动地去保存会话（如果会话设置失败，任务会直接结束）。接着获取选课的时间，最后将选课任务再次发送到`Celery`任务队列。
  4. 当到达任务设定的时间之后，`Celery-Worker`会不断的从任务队列中取出并执行任务。
  5. 当任务被执行后，调用相应的课程选择器来进行选课操作，期间任意一个关键步骤失败都会记录失败信息，失败后会重试。当到达最大重试次数后（这里设置的是3次），直接判定选课失败。
  6. 最后整个任务执行完毕。

+ ### 课程选择器设计思路

  课程选择器的本质其实就是一个爬虫程序，只不过就是经过反复抽象，最终成为了一个可扩展性非常强的课程选择器类。

  在`/snatcher/selector/base.py`下，定义了一个名为`BaseCourseSelector`的类，它是所有课程选择器类的父类。在这个类中没有编写任何的爬虫逻辑，只是为这个类初始化了一些属性和方法。

  在这个文件下有一个名为`CourseSelector`的派生类，本质上还是`BaseCourseSelector`这个类。只不过是希望外部类继承`CourseSelector`这个类罢了。

  而`CourseSelector`这个类又派生出了两个子类，他们分别是：

  + `SynchronousCourseSelector`

    同步课程选择器，该类所处的文件目录为：`/snatcher/selector/sync_selector.py`。该类表示所有发送请求使用的库都是`requests`。所有代码逻辑都是阻塞非异步的。

    在这个类中，实现了基本的选课操作，但它仍然不能够完成一个完整的选课请求。因此往下又派生出了两个子类：

    1. `SynchronousPublicChoiceCourseSelector`

       同步公选课课程选择器，它弥补了父类中的一些逻辑空缺，实现了完整的选课逻辑。

    2. `SynchronousPhysicalEducationCourseSelector`

       同步体育课课程选择器，与它的兄弟类作用基本一致。

  + `AsynchronousCourseSelector`

    异步课程选择器，该类所处的文件目录为：`/snatcher/selector/async_selector.py`。该类表示所有发送请求使用的库都是“aiohttp”。所有代码逻辑都是异步非阻塞的。

    和同步课程选择器一样，同样派生出了两个重要的子类：

    1. `AsynchronousPublicChoiceCourseSelector`
    2. `AsynchronousPhysicalEducationCourseSelector`

  __如果你觉得上述文字太多，那么你也可以通过观看以下这张图片清晰地了解课程选择器类的实现：__

  ![](image/%E8%AF%BE%E7%A8%8B%E9%80%89%E6%8B%A9%E5%99%A8.png)

+ ###  解耦式开发思想

  所谓“解耦”，就是低耦合。表示每个模块或者功能之间没有太多的依赖关系，每个模块或者功能单独拿出来也能够正常使用，提高了模块或者功能的可复用性。

  例如本项目中的课程选择器，单独拿出来也是可以使用的；还有`snatcher`整个包，不需要依赖前端的调用，手动调用也完全可以实现对应的功能，它提供了一个统一的对外接口，以至于让所有的Python程序都能够轻松的调用它。

  其实`snatcher`可以完全脱离前端和后端使用，只不过为了让这个系统对外部调用者显得更加友好，所以最终决定以Web的形式呈现到用户的眼中，同时也提高了整个系统的安全性。

## 关于项目部署

在部署方面，可能是这个项目最致命的缺点，在这里我详细的分析一下：

首先选课这个操作是必须要在校园网下进行的，也就是说当前网络是一个局域网。只有当前设备的网络环境处于校园网下，才能正常进行选课操作（当然，如果你是老师，有将会专属的VPN来访问校园网）。

所以整个发送请求的过程，都必须在本地进行，不能在云服务器上。因为云服务器的网络不是校园网，它是不能访问本地局域网的。当然，我也有想过让云服务器与本地局域网之间实现数据互通，但最终还是做不到……

因此刚开始我想的是把整个项目都部署在本地，通过内网穿透的形式将服务映射到外网，这种方式是行得通的。但是这样做会有一个弊端，由于内网穿透是通过端口映射的，也就是说只有当前端处于运行的状态下，才会暴露出一个端口，但是前端直接运行的代码是没有经过编译的，每一次网络传输都要传输大量的未经编译的数据，这样做的结果只有一个，那就是传输效率低，传输速度慢。这里是经过了实践的，将一个普通的Vue3应用映射出去，客户端的渲染时间达到了十几秒。

传输速度过慢以及客户端渲染的时间较长，可能是因为未编译过的前端文件过多再加上内网穿透的传输速度较慢，导致了客户端渲染的时间过长。

因此我最终决定__将前端打包放在云服务上，将后端的服务通过内网穿透映射出去__。在这里前后端都是使用JSON来进行交互的，而`JSON`本身是个轻量级数据，所以传输速度得到了一个很大的提升。加上前端本身是已经编译好的，所以客户端渲染的速度也非常快。

所以项目最终的部署方案是：将前端打包独自放在云服务器上，而其他所有资源都部署在本地。

这样部署的缺点就是只有当本地服务启动的时候，外部才能使用正常的服务。而本地服务是不能过长时间启动的，因为电脑总要关机嘛。所以我在开头的时候说部署是这个项目最致命的缺点就是这个意思。

## 关于项目首次上线遇到的一些问题

### 由于没有做好异常捕获从而导致很多任务提前终止

因为项目首次上线的时候还没有引入`异步Celery任务队列`，因此使用的课程选择器是基于`requests`包实现的，也就是`同步课程选择器`。

_`异步Celery任务队列`指的是使用`asyncio`包来实现并发的`Celery`；而官方提供的`Celery`是不支持`asyncio`来实现任务并发的。_

由于从发送请求到接收响应的过程是非常漫长的，一般大概在20分钟左右（我会尽量合理的设置请求超时的时间）。因此我可以预知到肯定会出现接收响应超时的情况，而对于`requests`来说，接收响应超时会抛出一个`requests.exceptions.ReadTimeout`异常，所以我明确的对所有发送请求的地方加上了对该异常的捕获，并且在生产环境中也正如我所料引发了对应的异常。__但是，在生产环境时还同时引发了多个我并未预知到的异常。__

下面我就列举出两个非常致命的异常：

* `requests.exceptions.ConnectTimeout`

  描述：该异常发生在与服务器建立连接的时候超时。

  原因：服务器接收的请求数量太多，后面的请求将排队等待连接，而这个等待连接的时间超出了提前设置好的请求超时时间。

  解决办法：最大可能的延长请求超时时间。

* `requests.exceptions.ConnectionError`

  描述：该异常发生在与服务器建立连接时，服务器拒绝了客户端的请求。

  原因：服务器接收的请求数量过多，导致服务器直接拒绝了部分客户端的请求。

  解决方法：既然这台服务器已经达到了可接收的最大请求数，那就可以考虑对另一台服务器发送请求。

为什么说这两个异常是最致命的呢？因为任意一个异常被引发，那么这个课程选择器将提前终止程序。再加上由于我的盲目自信，没有为Celery添加异常重试策略，所以结果可想而知……

### 复盘和总结

* _不要盲目自信，要为每一件事情和每一个情况提前做好最坏的打算。_
* _没有经过生产环境考验的项目是没有任何实际意义的。_

在项目处在开发和测试环境时，没有测试出任何的bug，这就带给我一种盲目乐观的心态，从而导致了悲观的发生……

也算是这次生产环境带给我的一个惨痛的教训，同时也由于自己的这些疏忽，没有帮助到更多的人完成选课，心里确实挺内疚的。

